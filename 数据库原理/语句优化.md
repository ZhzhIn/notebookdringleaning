###查询:
1.in与not in ，sql中包含in会导致性能有所降低，这是因为一般数据库引擎都会先试图将in语句转换为inner join等多个表的连接语句：如果转换不成功在依次执行in后括号内，括号外的查询，如果转换成功则按照链接的执行计划进行。因此in会增加一个转换的过程，导致耗费时间增加。如果在一个关系复杂的数据库中，这些转换锁花费的时间甚至会数倍于不适用in关键字的时间。
至于not in，由于他不是用表上的索引，对性能造成很大影响，不建议使用。in和not in的替代关键字是exists ，not exists
2.对字段为空的判断与null，字段是否为空一般不会调用索引查询，而是进行全表扫描，这是因为数据库引擎所采取的B数索引并不索引空值（位图索引包含控制，但更多应用于联机分析处理olap）
因此，根据实际使用情况，判断字符串是否为空可以用完成相同功能的其他操作运算来代替，比如 a is not null 改成a>0,或a>‘’等。另外，也可以用一个预先设定的特殊值来表示空值，这样会提高查询速度。
3.字段值的比较：比较操作符
<>,>,<等
<>不会用到索引，因此查询中包含他的话指挥进行全表扫描，根据实际应用情况，可以用完成相同功能的其他运算来代替，比如B<>0改为B>0 or B<0等。
大于小于操作符在执行sql是会采用索引查找，但可以根据实际应用情况进行优化。比如：如果实现了解数据的分布规律，那么在查询时讲条件写的越具体速度会越提高。
4.通配符查询：like
like在使用时要更具体，比如查询第二位为ABC的字段，like"%ABC%"，比like"*ABC%"化的时间更多
5.union
将多个表进行连接后会筛选掉重复的记录，因此会产生对结果集合的排序运算（要删除重复的记录以返回结果），这样的操作导致数据量大的时候数据引擎不得不利用磁盘空间在处理，从而性能变差。
改善的额方法时采用union all。他是简单的将两个表的查询结果合并后返回，这样的处理更常见。
6.尽量避免大块的实务操作，尽量分舵不进行。
7.避免使用cursor，这是由于它的焦虑交叉，可以考虑使用临时表
8.尽可能避免反复访问同一张或几张表，特别是数据量较大的表要避免在一个页面内反复访问。可以考虑的解决办法：根据条件提取数据到临时表中，然后再进一步操作；或采用把大表拆分的方法。
9.注意where后条件语句的编写，根据索引顺序，范围大小来确定条件子句的前后顺序，尽可能让字段顺序和索引顺序一致，范围从大到小，不要再where中的=左边行进函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引
10.尽量使用exists代替select count（1）来判断是否存在记录，count()函数只有在统计表中所有行数时使用，而且count（1）比count（*）更有效率
11.注意表之间连接（join）d的数据类型，避免不同类型数据之间的连接。
12.主要以insert update语句可能操作的数据量，以防止和其它操作冲突。比如，若数据量超过一定的数据页面数，数据库系统将会升级锁，导致整个表暂时无法更新，使得别的操作无法进行。
###索引
1.索引的创建要和服务结合考虑，建议大的用于联机查询的表一般不要超过6个
2.尽可能的使用索引字段作为查询条件，尤其是聚簇索引（clustered index)
3.避免对达标查询时进行全表扫描，如果有必要可以考虑新建索引
4.要注意索引的维护，设置周期性的索引重建计划，以适应数据量的变化。
###提高存储过程和自定义函数性能
1.注意存储过程中参数和数据类型的关系，尽量避免数据类型转换开销
2.对于存储过程中常用的临时表或tempdb,也要注意：
    1.尽量避免使用distinct，order by,group by ,having,join等增加工作负担的语句
    2.避免频繁创建和删除临时表，减少系统表资源的消耗
    3.新建临时表示，如果一次性插入数据量很大，那么可以使用select into语句代替create table语句，以避免日志操作，提高查询速度
    4.如果所操作的数据量不大，为了缓和系统表的资源，建议先创建表（使用create table），然后进行插入数据操作
    5.如果临时表中的数据量较大，需要建立索引，那么应该将创建临时表和建立索引的过程单独房子啊一个字存储过程中，这样才能保证系统能够很好的使用到该临时表的索引。
    6.对于临时表，在存储过程的最后务必将所有的临时表显式删除，限制性清理操作（使用truncate table)然后再删除表（使用drop table)这样可以避免系统表的较长时间锁定
    7.慎重使用大的临时表与其他达标的连接查询和修改，减低系统表负担，因为这种操作会在一条语句中多次使用tempdb的系统表。
###优化数据库的连接和关闭操作
使用连接池：连接池虽然提供了类似cache的功能，但是毕竟大小还是有限度的。如果服务在到达了连接池上线后再继续请求创建新的链接，对于性能的影响会更加大：没有连接池的时候直接建立链接即可，现在需要查询连接池再建立链接，增加了步骤。
###利用存储过程提高性能：
存储过程是指存储在数据库服务器上的一组预编译的sql。由于执行期间不必再便宜，因此执行速度能有所提高。
另外，存储过程再执行一次后，数据库引擎的执行计划一般会驻留在高速缓存中，再web应用的其他代码中如果调用同样的存储过程，则只需要利用该缓存中的二进制代码即可，会再次提高性能。
存储过程的好处还有节省网络带宽费用。web中查询在网络中传送会占用一定的网络带宽，但是用存储过程会减少这方面的消耗。
存储过程存放在数据库中，独立于服务端代码，便于提高安全性和维护修改。

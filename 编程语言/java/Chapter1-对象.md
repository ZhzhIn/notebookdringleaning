java编程思想 chapter1
### 对象导论
#### 对象的创建，使用和生命周期
OOP语言使用了**后期绑定**的概念，当想对象发送消息时，被调用的代码知道运行时才能确定，编译器确保被调用的方法存在，并对调用参数和返回值执行类型检查（无法提供子类保证的语言被称为时弱类型的），但是并不知道将被系执行的确切代码。
为了执行后期绑定，java使用一小段特殊的代码来替代绝对地址调用，这段代码使用在对象中存储的信息来计算方法体的地址（这个过程在java编程思想chapter7中详述）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当像一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。
#### 堆 
java在被称为堆的内存池中动态的创建对象。这种方式中，知道运行时才知道需要多少对象，他们的生命周期如何，他们的具体类型是什么。这些答案在程序运行时相关代码被执行的时候才能确定，编译器对他的生命周期一无所知，java的垃圾回收器可以自动发现对象何时不再被使用，并继而销毁它。

存储空间时在运行时被动态管理的，所以 分配存储空间的时间>>创建存储空间的时间。
堆是不连续的存储空间，类似链表，栈是连续的存储空间。
#### 集合和迭代器
//TODO 看一下迭代器的源码
想操作一组容器中的元素，解决方法是用迭代器。
从设计的观点来看，真正需要的只是一个可以被操作，从而解决问题的序列。不同的容器，就需要设计不同类型的序列。
1.不同容器提供了不同类型的接口和外部行为；
2.不同容器对于某些操作具有不同的效率（ArrayList,LinkedList，前者访问快，后者插入快)
#### 单根继承结构
让垃圾回收器更容易实现。
单根继承结构，保证所有的对象都具备某些功能，单根继承结构以及在对上创建所有对象，极大地简化了参数传递。
单根继承结构使垃圾回收器的实现变得容易很多，其必须的支持功能可置于基类中，这样，垃圾回收器就可以发送恰当的消息给系统中的每一个对象。
#### 向下转型与泛型
单根继承结构意味着所有的东西都是对象，所以可以存储Object的容器可以存储任何东西。
如果有这样的容器，只需要存入对象引用，稍后还能取回，要多好。
但是存入使用下上转型（安全），取出需要向下转型（不安全），怎么做安全的向下转型？
如果向下转型为错误的类型，就会得到异常的运行时错误。
向下转型和运行时的检查需要额外的程序运行时间。创建这样的容器，它知道自己所保存的对象的类型，从而不需要向下转型以及消除犯错误的可能，这种方案成为参数化类型机制。
参数化类型就是一个编译器可以自动定制作用于特定类型上的类。
#### 确保正确回收
在堆上创建对象可能价格比在堆栈上创建高昂得多，总是从某个基类继承以及所有的方法调用都是多态的也需要小部分开销。
#### 并发性
多线程有个一个隐患:共享资源。某个县城锁定某项资源，完成其任务，然后释放资源所，使其他线程可以使用这项资源。
java可以锁定任何对象所占用的内存（这也算某种共享资源）使得某一时刻只能有一个线程在使用它。这是通过synchronized关键字来实现的。其他类型的资源必须由程序员现实的锁定，通常是创建一个表时所的对象，所有线程在访问资源之前先检查这个对象。
### 一切皆对象
存储数据的地方：
1.寄存器，最快，位于CPU内部。
2.堆栈，在RAM中，通过堆栈指针可以从cpu获得直接支持。堆栈指针向下移动，分配新的内存；向上移动，释放内存。
创建程序时，java编译器必须知道存储在堆栈内的所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。
3.堆。一种通用内存池（RAM中），用于存放java对象。堆不同于对战的好处是，编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此在堆里分配存储有很大的灵活性。
4.静态存储，这里的静态是指在固定的位置（也是RAM中）。静态存储里存放程序运行时一直存在的数据，可用关键字static来表示某个对象的特定元素是静态的，但java对象本身从来不会存放在静态存储空间里。
5.常量存储，常量值通常直接存放在程序代码内部，因为他们永远不会被改。
6.非RAM存储，如果数据完全存活于程序之外，那么它可以不受程序的控制，在程序没有运行时也可以存在，比如流对象和持久化对象。之旧话对象被放在磁盘上。
#### 基本类型
1.new对象存储在堆里，new很小的变量就不是很高效，因此，基本类型的初始化，是new一个不是引用的“自动”变量。这个变量拥有“值”,并放在堆栈中，因此更加高效。




例子：Date a = new Date()
### 理论：
1.在java中，任何对象变量的值a，都是对存储在另外一个地方的一个对象Date的引用。
2.所有的java对象都是在堆中构建的。实例化一个对象，会在内存中开辟一个空间。
### Tips:
1.不要编写返回引用可变对象的访问器(getObject)方法（私有属性是对象，但是对象有其他的公共方法可以修改该对象的值，比如私有属性是Date,参考SimpleDateFormator）
    如果需要返回一个可变对象的引用，应该首先对他进行clone，对象clone是指存放在另一个位置上的对象副本。javaCore p113
### 方法
1.按值调用 call by value :表示方法接收到的是调用者提供的值
2.按引用调用 call by reference: 表示方法接收的是调用者提供的变量的地址。
3.java**总是**按值调用。方法接收到的是所有参数值的一个拷贝，方法不能修改传递给他的任何参数变量的内容。
    - 例，triple(int a),修改int后，如果不返回，原来的a值不变。
    - 例，triple(Employee a),修改参数后，原来的a的参数会改变，因为triple中使用的是a的地址的引用拷贝。
    - 例，swap(Employee a,Employee b),交换通过temp实现时，并不生效，因为交换的是两个引用地址的拷贝，原来的引用地址不变。
总结：
1.一个方法不能修改一个基本数据类型的参数
2.一个方法可以改变一个对象参数的状态
3。一个方法不能然对象参数引用一个新的对象
